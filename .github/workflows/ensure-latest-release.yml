name: Ensure Latest Tag Release

on:
  push:
    branches: ["main"]
    tags:
      - "v*.*.*"
  workflow_dispatch: {}

permissions:
  contents: write

jobs:
  ensure-release:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Fetch tags
        run: git fetch --tags --force

      - name: Determine latest semver tag
        id: tag
        run: |
          if [ "${GITHUB_REF_TYPE}" = "tag" ]; then
            echo "tag_name=${GITHUB_REF_NAME}" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          python - <<'PY' > tag.txt
          import re, subprocess
          tags = subprocess.check_output(["git", "tag", "--list", "v*.*.*"], text=True).split()
          tags = [t for t in tags if re.match(r"^v\\d+\\.\\d+\\.\\d+$", t)]
          def key(t):
            a,b,c = map(int, t[1:].split("."))
            return (a,b,c)
          tags.sort(key=key)
          if not tags:
            raise SystemExit("Geen semver tags gevonden.")
          print(tags[-1])
          PY
          echo "tag_name=$(cat tag.txt)" >> "$GITHUB_OUTPUT"

      - name: Create or update release for latest tag
        uses: actions/github-script@v7
        env:
          TAG_NAME: ${{ steps.tag.outputs.tag_name }}
        with:
          script: |
            const fs = require("fs");

            function extractChangelogSection(changelogText, version) {
              const lines = String(changelogText || "").split(/\r?\n/);
              const headerPrefix = `## [${version}]`;

              let start = -1;
              for (let i = 0; i < lines.length; i++) {
                if (lines[i].startsWith(headerPrefix)) {
                  start = i;
                  break;
                }
              }
              if (start === -1) return null;

              const out = [];
              for (let i = start; i < lines.length; i++) {
                if (i !== start && lines[i].startsWith("## [")) break;
                out.push(lines[i]);
              }
              return out.join("\n").trim();
            }

            const tag = process.env.TAG_NAME || "";
            if (!tag) {
              core.setFailed("TAG_NAME ontbreekt.");
              return;
            }
            const version = tag.startsWith("v") ? tag.slice(1) : tag;

            const changelog = fs.readFileSync("CHANGELOG.md", "utf8");
            const body = extractChangelogSection(changelog, version);
            if (!body) {
              core.setFailed(`Kon geen CHANGELOG sectie vinden voor versie ${version} (tag: ${tag}).`);
              return;
            }

            const { owner, repo } = context.repo;

            let release = null;
            try {
              const existing = await github.rest.repos.getReleaseByTag({ owner, repo, tag });
              release = existing.data;
            } catch (e) {
              if (e.status !== 404) throw e;
            }

            if (release) {
              await github.rest.repos.updateRelease({
                owner,
                repo,
                release_id: release.id,
                name: tag,
                body,
                draft: false,
                prerelease: false
              });
              core.info(`Release ${tag} bijgewerkt.`);
              return;
            }

            await github.rest.repos.createRelease({
              owner,
              repo,
              tag_name: tag,
              name: tag,
              body,
              draft: false,
              prerelease: false,
              make_latest: "true"
            });
            core.info(`Release ${tag} aangemaakt.`);
